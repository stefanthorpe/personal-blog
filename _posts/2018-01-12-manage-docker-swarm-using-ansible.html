---
layout: post
status: publish
published: true
title: 12 Steps to Managing Docker Swarm Using Ansible
author:
  display_name: Julia Pearson
  login: julia
  email: julia@caylent.com
  url: ''
author_login: julia
author_email: julia@caylent.com
wordpress_id: 2483
wordpress_url: https://caylent.com/?p=2483
date: '2018-01-12 11:00:11 +0200'
date_gmt: '2018-01-12 19:00:11 +0200'
categories:
- Docker
- Resources
- Walkthroughs
- Ansible
tags:
- AWS
- Docker Swarm
- Ansible
comments: []
---
<p>Want to standardize and automate your whole Docker Swarm management? Are you inspired by our article <a href="https://caylent.com/high-availability-docker-swarm-aws/" target="_blank" rel="noopener">Creating a High-Availability Docker Swarm on AWS</a> and now wish to reduce the repetition every time you need a swarm?</p>
<p>Well, we&rsquo;ve got you covered with the help of <a href="https://www.ansible.com/" target="_blank" rel="noopener">Ansible</a>. In the following article, we&rsquo;ll lead you through an Ansible playbook that installs a fresh version of Docker, establishes a node as your Docker Swarm manager, and adds additional managers and workers to your swarm until you have a high-availability cluster. Furthermore, the process creates a default Docker network to enable the nodes to communicate properly.</p>
<h1>Caylent's Ansible/Docker Swarm Playbook Guide</h1>
<h2>1. Setup Prerequisites</h2>
<p>Here&rsquo;s a link to the hosts file and playbook on GitHub which you need for Ansible to build out a Docker Swarm: <a href="https://github.com/caylent/ansible-docker-swarm" target="_blank" rel="noopener">Caylent/Ansible-Docker-Swarm</a><br />
On top of this, for the sake of this article, you&rsquo;ll need to have a few other things already in place:</p>
<ul>
<li>A network of connected machines (i.e. a virtual private cloud (VPC))</li>
<li>At least 2 public subnets</li>
<li>5 EC2 instances on AWS with an elastic load balancer (ELB)</li>
</ul>
<p>Set these ingress rules on your EC2 security groups:</p>
<ul>
<li>HTTP port 80 from 0.0.0.0\0</li>
<li>SSH from 0.0.0.0\0 (for increased security, replace this with your own IP address)</li>
</ul>
<p>Once your machines are configured correctly we can begin. We&rsquo;re using Ubuntu 14.04 LTS, though the process will work similarly on other Linux-based operating systems too.</p>
<h2>2. Assign Nodes</h2>
<p>Before diving into the rest of the tasks that will install Docker and start up the swarm, it&rsquo;s necessary to detail the specifications of the nodes outlined on AWS. The image below shows the hosts file which specifies the nodes needed to create managers and workers and specifies the role each node will undertake.<br />
Fill in the IP addresses accordingly to assign your nodes, replacing <code>{{ manager->ip }}</code>{with your intended master node IPs and <code>{{ worker->ip}}</code> with your intended worker ones. If you prefer to have 5 masters you can fill those in continuing with the format shown for the first 3 and same with additional workers. As we&rsquo;ve mentioned before, it&rsquo;s important to always create an odd number of masters in your Swarm; as a &lsquo;majority&rsquo; vote is needed between managers to define the lead instance. This works in accordance with Docker&rsquo;s raft protocol.</p>
<p><code>[docker-manager-first]<br />
manager1 ansible_host="{{manager1->ip}}"</code></p>
<p><code>[docker-managers]<br />
manager2 ansible_host="{{manager2->ip}}"<br />
manager3 ansible_host="{{manager3->ip}}"</code></p>
<p><code>[docker-workers]<br />
worker1 ansible_host="{{worker1->ip}}"<br />
worker2 ansible_host="{{worker2->ip}}"</code></p>
<p><code>[docker-api]<br />
manager1<br />
manager2<br />
manager3</code></p>
<p><code>[docker-cloud]<br />
manager1<br />
manager2<br />
manager3</code></p>
<p>&nbsp;</p>
<h2>3. Customize Variables</h2>
<p>You will also need to customize the group variables in group_vars/all.yml to reflect your own SSH username and the path to your private key.</p>
<p><code>ansible_ssh_user: {{ssh-username}}<br />
ansible_ssh_private_key_file: "{{~/path/to/your/ssh_private_key}}"<br />
ansible_host_key_checking: false<br />
</code><br />
Now that you&rsquo;ve supplied Ansible with the necessary information to access your nodes, you can run the playbook. Each set of commands will automatically loop until completed, meaning very little input is required on your part&mdash;with the exception of some copy and pasting.</p>
<p>To run the playbook, enter the following command in the root folder of the cloned repo:<br />
<code>$ ansible-playbook docker-ce.yaml -i hosts.ini</code></p>
<h2>4. Install Ubuntu and Docker</h2>
<p>The following code operates on all hosts; both managers and workers.<br />
<code>hosts: all<br />
remote_user: root<br />
become: yes<br />
become_method: sudo<br />
tasks:</code></p>
<p>The following tasks check that no previous installs of Docker exist on your nodes.</p>
<p><code>name: "add docker repository"<br />
apt_repository: repo='deb [arch=amd64] https://download.docker.com/linux/ubuntu {{ ansible_distribution_release }} stable' state=present<br />
when: ansible_distribution == "Ubuntu"</code></p>
<p><code>name: "ensure old versions of docker are purged 1"<br />
apt: name=lxc-docker state=absent purge=yes<br />
when: ansible_distribution == "Ubuntu"</code></p>
<p><code>name: "ensure old versions of docker are purged 2"<br />
apt: name=docker state=absent purge=yes<br />
when: ansible_distribution == "Ubuntu"</code></p>
<p><code>name: "ensure old versions of docker are purged 3"<br />
apt: name=docker-engine state=absent purge=yes<br />
when: ansible_distribution == "Ubuntu"</code></p>
<p><code>name: "ensure old versions of docker are purged 4"<br />
apt: name=docker.io state=absent purge=yes<br />
when: ansible_distribution == "Ubuntu"</code></p>
<p>The following tasks check the current kernel version and then downloads dependencies for Ubuntu 14.04.<br />
<code>name: "get kernel version"<br />
shell: uname -r<br />
register: kernel</code></p>
<p><code>name: "install 14.04 pre-req 1"<br />
apt:<br />
name: linux-image-extra-{{ kernel.stdout }}<br />
state: present<br />
update_cache: yes<br />
install_recommends: yes<br />
when: ansible_distribution == "Ubuntu"<br />
retries: 3<br />
delay: 20</code></p>
<p><code>name: "install 14.04 pre-req 2"<br />
apt: name=linux-image-extra-virtual state=present update_cache=yes install_recommends=yes<br />
when: ansible_distribution == "Ubuntu"<br />
retries: 3<br />
delay: 20</code></p>
<p>The following task installs your preferred Docker version. Our example input is '17.06.2*&rsquo;.</p>
<p><code>name: "install docker"<br />
apt: name=docker-ce=17.06.2* state=present update_cache=yes install_recommends=yes allow_unauthenticated=yes<br />
when: ansible_distribution == "Ubuntu"<br />
retries: 3<br />
delay: 20</code></p>
<h2>5. Create Docker Group</h2>
<p>The following tasks create a Docker group, add Ubuntu as a user, and restart the service so that we don&rsquo;t need to use sudo every time we use a Docker command.<br />
<code>name: "add docker group"<br />
group: name=docker state=present</code></p>
<p><code>name: "add ubuntu to docker group"<br />
user: name=ubuntu groups=docker append=yes</code></p>
<p><code>name: "restart docker service"<br />
service: name=docker state=started</code></p>
<p><code>name: "get docker info"<br />
shell: docker info<br />
register: docker_info<br />
changed_when: false</code></p>
<h2>6. Initiate the Swarm</h2>
<p>The following tasks will run on the first manager as specified above in the hosts file.<br />
<code>hosts: docker-manager-first<br />
remote_user: root<br />
become: yes<br />
become_method: sudo<br />
tasks:</code><br />
The following tasks initiate a Docker Swarm and then save the master and worker tokens so we can add more hosts to the cluster.<br />
<code>name: "create primary swarm manager"<br />
shell: docker swarm init --advertise-addr {{ ansible_eth0['ipv4']['address'] }}<br />
when: "docker_info.stdout.find('Swarm: inactive') != -1"</code></p>
<p><code>name: "get docker swarm manager token"<br />
shell: docker swarm join-token -q manager<br />
register: manager_token</code></p>
<p><code>name: "get docker swarm worker token"<br />
shell: docker swarm join-token -q worker<br />
register: worker_token</code></p>
<h2>7. Add Managers to the Swarm</h2>
<p>The following tasks run on all nodes designated as &lsquo;docker-managers&rsquo; in the hosts file, adding each to the swarm as managers.<br />
<code>hosts: docker-managers<br />
remote_user: root<br />
become: yes<br />
become_method: sudo<br />
tasks:</code></p>
<p><code>name: "join as a manager"<br />
shell: "docker swarm join --token {{ hostvars['manager1']['manager_token']['stdout'] }} {{ hostvars['manager1']['ansible_eth0']['ipv4']['address'] }}:2377"<br />
when: docker_info.stdout.find("Swarm{{':'}} inactive") != -1<br />
retries: 3<br />
delay: 20</code></p>
<h2>8. Add Workers to the Swarm</h2>
<p>The following tasks add all nodes designated as &lsquo;docker-workers&rsquo; in the hosts file to your swarm as workers.<br />
<code>hosts: docker-workers<br />
remote_user: root<br />
become: yes<br />
become_method: sudo<br />
tasks:</code></p>
<p><code>name: "join as a worker"<br />
shell: "docker swarm join --token {{ hostvars['manager1']['worker_token']['stdout'] }} {{ hostvars['manager1']['ansible_eth0']['ipv4']['address'] }}:2377"<br />
when: "docker_info.stdout.find('Swarm: inactive') != -1"<br />
retries: 3<br />
delay: 20</code></p>
<h2>9. Expose Docker API</h2>
<p>The following tasks will run on all manager nodes that were previously designated in the hosts file under <code>&lsquo;docker-api&rsquo;</code>. The commands confirm that the API is running on these nodes and is exposed. If not, the task stops Docker, exposes it, and restarts the service.<br />
<code>hosts: docker-api<br />
remote_user: root<br />
become: yes<br />
become_method: sudo<br />
tasks:</code></p>
<p><code>name: "confirm service exists"<br />
stat: path=/etc/init.d/docker<br />
register: service_wrapper</code></p>
<p><code>name: "check whether api already exposed"<br />
command: "grep 'DOCKER_OPTS=\"-D -H tcp://0.0.0.0:4243 -H unix:///var/run/docker.sock\"' /etc/default/docker"<br />
register: check_has_api<br />
always_run: True<br />
ignore_errors: True<br />
changed_when: False</code></p>
<p><code>name: "stop docker"<br />
service: name=docker state=stopped<br />
when:<br />
service_wrapper.stat.exists<br />
check_has_api.stdout == ""<br />
register: service_stopped</code></p>
<p><code>name: "expose docker api"<br />
lineinfile: "dest=/etc/default/docker state=present regexp='#DOCKER_OPTS=' line='DOCKER_OPTS=\"-H tcp://0.0.0.0:4243 -H unix:///var/run/docker.sock\"'"<br />
when:<br />
ervice_stopped<br />
check_has_api.stdout == ""</code></p>
<p><code>name: "restart docker service"<br />
service: name=docker state=started<br />
when:<br />
service_wrapper.stat.exists<br />
check_has_api.stdout == ""</code></p>
<h2>10. Create Daemon File</h2>
<p>The following tasks will run on all the manager nodes which were designated in the hosts file under &lsquo;docker-cloud&rsquo; and confirms that there is a Daemon file on each. If not, it stops Docker, creates a daemon file, and restarts the service.<br />
<code>hosts: docker-cloud<br />
remote_user: root<br />
become: yes<br />
become_method: sudo<br />
tasks:</code></p>
<p><code>name: "confirm service exists"<br />
stat: path=/etc/init.d/docker<br />
register: service_wrapper</code></p>
<p><code>name: "check for daemon file"<br />
stat: path=/etc/docker/daemon.json<br />
register: daemon_file</code></p>
<p><code>name: "stop docker"<br />
service: name=docker state=stopped<br />
when:<br />
service_wrapper.stat.exists<br />
not daemon_file.stat.exists<br />
register: service_stopped</code></p>
<p><code>name: "create daemon file"<br />
template: src=templates/daemon.j2 dest=/etc/docker/daemon.json<br />
when: not daemon_file.stat.exists</code></p>
<p><code>name: "restart docker service"<br />
service: name=docker state=started<br />
when:<br />
service_wrapper.stat.exists</code></p>
<h2>11. List Networks</h2>
<p>The following task lists the networks on your Docker manager. This output will determine if the default network still needs to be created.<br />
<code>hosts: docker-manager-first<br />
remote_user: root<br />
become: yes<br />
become_method: sudo<br />
tasks:</code></p>
<p><code>name: list networks<br />
shell: docker network ls<br />
register: docker_networks</code></p>
<h2>12. Expand Networks</h2>
<p>After checking if the default network exists, Ansible will work through the list of networks provided and create each one with the specified subnet, gateway, and appropriate name. This network allows containers within this service to communicate properly.<br />
<code>name: create network when not there<br />
shell: docker network create --driver overlay --subnet {{ item.subnet }} --gateway {{ item.gateway }} {{ item.name }}<br />
with_items:<br />
{name: 'caylent-default',<br />
subnet: '17.0.0.0/16',<br />
gateway: '17.0.0.1'}<br />
when: docker_networks.stdout.find( item.name ) == -1</code></p>
<p>Congratulations, you&rsquo;re all finished and the entire process is now automated! Alternatively, we invite you to get <a href="https://caylent.com/sign-up-2/?utm_source=direct&amp;utm_medium=blog%20conc&amp;utm_campaign=ansible%20blog" target="_blank" rel="noopener">started using Caylent today</a> which completes the whole thing for you. Our DevOps container management platform helps software teams manage containers, clouds, and microservices with ease.</p>
<p>As always, we'd love your feedback and suggestions for future articles.</p>
